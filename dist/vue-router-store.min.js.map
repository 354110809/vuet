{"version":3,"file":"vue-router-store.min.js","sources":["../src/install.js","../src/options.js","../src/utils.js","../src/debug.js","../src/vue-router-store.js","../src/index.js"],"sourcesContent":["export let _Vue = null\n\nconst isDef = v => v !== undefined\n\nexport default function install (Vue) {\n  if (install.installed) return\n  install.installed = true\n  _Vue = Vue\n  Object.defineProperty(Vue.prototype, '$vrs', {\n    get () { return this.$root._vrs }\n  })\n  Object.defineProperty(Vue.prototype, '$rs', {\n    get () { return this.$root._vrs.store }\n  })\n  Vue.mixin({\n    beforeCreate () {\n      if (isDef(this.$options.vrs)) {\n        this._vrs = this.$options.vrs\n      }\n    }\n  })\n}\n","export default function options (opt = {}) {\n  const options = {\n    pagekey: 'page', // this.$route.query[pagekey]\n    queryKey: 'query', // this.$data[queryKey]\n    fetchBefore () {\n      // Callback method before requesting to send\n      // This points to the component instance\n    },\n    fetchAfter () {\n      // After the request ends, the callback method, regardless of success or failure\n      // This points to the component instance\n    },\n    baseData () {\n      // All use\n      return {}\n    },\n    baseListData () {\n      // List all use\n      return {}\n    },\n    baseDetailData () {\n      // Detail all use\n      return {}\n    },\n    fetchSuccess (res, type) {\n      // Request successful callback\n    },\n    fetchError (e, type) {\n      // Request failed callback\n    },\n    modules: {}\n  }\n  return Object.assign(options, opt)\n}\n","const utils = {\n  isObject (obj) {\n    return Object.prototype.toString.call(obj) === '[object Object]'\n  },\n  isArray (arr) {\n    return Object.prototype.toString.call(arr) === '[object Array]'\n  },\n  isFunction (arr) {\n    return Object.prototype.toString.call(arr) === '[object Function]'\n  },\n  next (fn, resolve, reject = (e) => {}) {\n    let btn = false\n    const back = fn(resolve, reject)\n    if (typeof back === 'object' && utils.isFunction(back.then)) {\n      back\n        .then((res) => {\n          if (btn) return\n          btn = true\n          resolve(res)\n        })\n        .catch(reject)\n    }\n  }\n}\nexport default utils\n","export default {\n  error (msg) {\n    throw new Error(`[vue-router-store] ${msg}`)\n  },\n  warn (msg) {\n    if (process.env.NODE_ENV !== 'production') {\n      typeof console !== 'undefined' && console.warn(`[vue-router-store] ${msg}`)\n    }\n  }\n}\n","import { _Vue } from './install'\nimport options from './options'\nimport utils from './utils'\nimport debug from './debug'\n\nexport default class VueRouterStore {\n  constructor (opt) {\n    this.options = options(opt = opt || {})\n    this._init()\n  }\n  _init () {\n    const store = {}\n    const _fetchKey = {}\n    Object.keys(this.options.modules).forEach(name => {\n      store[name] = {\n        list: this._getData(name, 'list'),\n        detail: this._getData(name, 'detail')\n      }\n      _fetchKey[name] = {\n        list: '',\n        detail: ''\n      }\n    })\n    this.store = new _Vue({\n      data: {\n        store\n      }\n    }).$data.store\n    this._fetchKey = _fetchKey\n  }\n  _getModuleOptions (name, type) {\n    const options = this.options.modules[name]\n    const defaults = {\n      pagekey: this.options.pagekey,\n      queryKey: this.options.queryKey,\n      fetch () {\n        return {}\n      },\n      data () {\n        return {}\n      }\n    }\n    Object.keys(options).forEach(k => {\n      let name = (k.split(type)[1] || '')\n      name = name.replace(/^(\\w)/, (v) => v.toLowerCase()) // 首字母大写\n      if (name) {\n        defaults[name] = options[k]\n      }\n    })\n    return defaults\n  }\n  _returnComput (comput, diy) {\n    const obj = {}\n    if (!diy.length) return comput\n    diy.forEach(k => {\n      obj[k] = comput[k]\n    })\n    return obj\n  }\n  _getData (name, type) {\n    const data = this.options.baseData.call(this, name, type)\n    switch (type) {\n      case 'list':\n        Object.assign(data, this.options.baseListData.call(this, name))\n        break\n      case 'detail':\n        Object.assign(data, this.options.baseDetailData.call(this, name))\n        break\n    }\n    const options = this._getModuleOptions(name, type)\n    return Object.assign(data, options.data.call(this))\n  }\n  _clearStore (name, type) {\n    const data = this._getData(name, type)\n    this._setStore(name, type, data)\n  }\n  _getStore (name, type) {\n    return this.store[name][type]\n  }\n  _setStore (name, type, data) {\n    const store = this.store[name][type]\n    Object.assign(store, data)\n  }\n  _getComputed (name, type) {\n    const store = this.store[name][type]\n    const computed = {}\n    Object.keys(store).forEach(k => {\n      computed[k] = {\n        get () {\n          return store[k]\n        },\n        set (val) {\n          store[k] = val\n        }\n      }\n    })\n    return computed\n  }\n  _setFetchKey (name, type, val) {\n    this._fetchKey[name][type] = String(val)\n  }\n  _getFetchKey (name, type) {\n    return this._fetchKey[name][type]\n  }\n  listStore (name, ...diy) {\n    const self = this\n    const type = 'list'\n    const options = self._getModuleOptions(name, type)\n    const computed = {\n      ...self._getComputed(name, type),\n      $rsList () {\n        const vm = this\n\n        function rsList () {\n          const fetch = self._getModuleOptions(name, type).fetch\n          if (!utils.isFunction(fetch)) {\n            return debug.error(`${type} fetch method is undefined`)\n          }\n          const fullPath = vm.$route.fullPath\n          self.options.fetchBefore.call(vm, name, type)\n          utils.next(fetch.bind(vm), (res) => {\n            const back = self.options.fetchSuccess.call(vm, res, name, type)\n            if (utils.isObject(back)) {\n              res = back\n            }\n            if (fullPath !== vm.$route.fullPath) return\n            self._setStore(name, type, res)\n            self._setFetchKey(name, type, fullPath)\n            self.options.fetchAfter.call(vm, name, type)\n          }, (e) => {\n            self.options.fetchError.call(vm, e, name, type)\n            self.options.fetchAfter.call(vm, name, type)\n          })\n        }\n        rsList.init = function init () {\n          self._clearStore(name, type)\n        }\n\n        rsList.search = function search (...arg) {\n          let query = {}\n          /* eslint-disable no-undef */\n          if (typeof event === 'object' && event === arg[0]) {\n            arg[0] = {}\n          }\n          if (utils.isObject(arg[0])) { // search({})\n            query = arg[0]\n          } else if (typeof arg[0] === 'string') { // search('key', val)\n            query[arg[0]] = arg[1]\n          }\n          query = Object.assign({}, vm.$route.query, { [options.pagekey]: '1' }, vm[options.queryKey], query)\n          vm.$router.push({\n            ...vm.$route,\n            query\n          })\n        }\n        rsList.syncQuery = function syncQuery () {\n          const query = vm[options.queryKey]\n          if (utils.isObject(query)) {\n            Object.keys(query).forEach((k) => {\n              if (Object.prototype.hasOwnProperty.call(vm.$route.query, k)) {\n                query[k] = vm.$route.query[k]\n              }\n            })\n          }\n        }\n        return rsList\n      }\n    }\n    return this._returnComput(computed, diy)\n  }\n  listMixin (name) {\n    const self = this\n    const type = 'list'\n    return {\n      beforeRouteEnter (to, from, next) {\n        const key = self._getFetchKey(name, type)\n        const toKey = to.fullPath\n        if (!key) {\n          self._setFetchKey(name, type, toKey)\n        } else if (key !== toKey) {\n          self._clearStore(name, type)\n          self._setFetchKey(name, type, toKey)\n        }\n        if (utils.isFunction(next)) {\n          next()\n        }\n      },\n      computed: self.listStore(name),\n      created () {\n        this.$rsList.syncQuery()\n        this.$rsList()\n      },\n      watch: {\n        '$route.fullPath' () {\n          this.$rsList.syncQuery()\n          this.$rsList()\n        }\n      }\n    }\n  }\n  detailStore (name, ...diy) {\n    const self = this\n    const type = 'detail'\n    const computed = {\n      ...self._getComputed(name, type),\n      $rsDetail () {\n        const vm = this\n        function rsDetail () {\n          const key = vm.$route.path\n          if (!key) return\n          const fetch = self._getModuleOptions(name, type).fetch\n          if (!utils.isFunction(fetch)) {\n            return debug.error(`${type} fetch method is undefined`)\n          }\n          self.options.fetchBefore.call(vm, name, type)\n          utils.next(fetch.bind(vm), (res) => {\n            const back = self.options.fetchSuccess.call(vm, res, name, type)\n            if (utils.isObject(back)) {\n              res = back\n            }\n            if (key !== vm.$route.path) return\n            self._setStore(name, type, res)\n            self._setFetchKey(name, type, key)\n            self.options.fetchAfter.call(vm, name, type)\n          }, (e) => {\n            self.options.fetchError.call(vm, e, name, type)\n            self.options.fetchAfter.call(vm, name, type)\n          })\n        }\n        rsDetail.init = function init () {\n          self._clearStore(name, type)\n        }\n        return rsDetail\n      }\n    }\n    return this._returnComput(computed, diy)\n  }\n  detailMixin (name) {\n    const self = this\n    const type = 'detail'\n    return {\n      beforeRouteEnter (to, from, next) {\n        const key = self._getFetchKey(name, type)\n        if (!key) {\n          self._setFetchKey(name, type, to.path)\n        } else if (key && key !== to.path) {\n          self._clearStore(name, type)\n          self._setFetchKey(name, type, to.path)\n        }\n        if (utils.isFunction(next)) {\n          next()\n        }\n      },\n      computed: self.detailStore(name),\n      created () {\n        this.$rsDetail()\n      },\n      watch: {\n        '$route.path' () {\n          this.$rsDetail()\n        }\n      }\n    }\n  }\n}\n","import VueRouterStore from './vue-router-store'\nimport install from './install'\n\nVueRouterStore.install = install\n\nexport default VueRouterStore\n"],"names":["install","Vue","installed","defineProperty","prototype","this","$root","_vrs","store","mixin","isDef","$options","vrs","options","opt","res","type","e","Object","assign","_Vue","undefined","v","utils","obj","toString","call","arr","fn","resolve","reject","btn","back","isFunction","then","catch","msg","Error","VueRouterStore","_init","_fetchKey","keys","modules","forEach","name","_this","_getData","$data","defaults","pagekey","queryKey","k","split","replace","toLowerCase","comput","diy","length","data","baseData","baseListData","baseDetailData","_getModuleOptions","_setStore","computed","val","String","self","_getComputed","rsList","fetch","debug","error","fullPath","vm","$route","fetchBefore","next","bind","fetchSuccess","isObject","_setFetchKey","fetchAfter","fetchError","init","_clearStore","search","query","arg","event","$router","push","syncQuery","hasOwnProperty","_returnComput","to","from","key","_getFetchKey","toKey","listStore","$rsList","rsDetail","path","detailStore","$rsDetail"],"mappings":"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"}