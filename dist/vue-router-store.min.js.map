{"version":3,"file":"vue-router-store.min.js","sources":["../src/install.js","../src/options.js","../src/utils.js","../src/debug.js","../src/vue-router-store.js","../src/index.js"],"sourcesContent":["export let _Vue = null\n\nconst isDef = v => v !== undefined\n\nexport default function install (Vue) {\n  if (install.installed) return\n  install.installed = true\n  _Vue = Vue\n  Object.defineProperty(Vue.prototype, '$vrs', {\n    get () { return this.$root._vrs }\n  })\n  Object.defineProperty(Vue.prototype, '$rs', {\n    get () { return this.$root._vrs.store }\n  })\n  Vue.mixin({\n    beforeCreate () {\n      if (isDef(this.$options.vrs)) {\n        this._vrs = this.$options.vrs\n      }\n    }\n  })\n}\n","export default function options (opt = {}) {\n  const options = {\n    pagekey: 'page', // this.$route.query[pagekey]\n    queryKey: 'query', // this.$data[queryKey]\n    detailParamsKey: 'id', // this.$route.params[detailParamsKey]\n    fetchBefore (name, type) {\n      // Callback method before requesting to send\n      // This points to the component instance\n    },\n    fetchAfter (name, type) {\n      // After the request ends, the callback method, regardless of success or failure\n      // This points to the component instance\n    },\n    fetchSuccess (res, name, type) {\n      // Request successful callback\n    },\n    fetchError (e, name, type) {\n      // Request failed callback\n    },\n    baseData (name, type) {\n      // All use\n      return {}\n    },\n    baseListData (name) {\n      // List all use\n      return {}\n    },\n    baseDetailData (name) {\n      // Detail all use\n      return {}\n    },\n    modules: {}\n  }\n  return Object.assign(options, opt)\n}\n","const utils = {\n  isObject (obj) {\n    return Object.prototype.toString.call(obj) === '[object Object]'\n  },\n  isArray (arr) {\n    return Object.prototype.toString.call(arr) === '[object Array]'\n  },\n  isFunction (arr) {\n    return Object.prototype.toString.call(arr) === '[object Function]'\n  },\n  next (fn, resolve, reject = (e) => {}) {\n    let btn = false\n    const back = fn(resolve, reject)\n    if (typeof back === 'object' && utils.isFunction(back.then)) {\n      back\n        .then((res) => {\n          if (btn) return\n          btn = true\n          resolve(res)\n        })\n        .catch(reject)\n    }\n  }\n}\nexport default utils\n","export default {\n  error (msg) {\n    throw new Error(`[vue-router-store] ${msg}`)\n  },\n  warn (msg) {\n    if (process.env.NODE_ENV !== 'production') {\n      typeof console !== 'undefined' && console.warn(`[vue-router-store] ${msg}`)\n    }\n  }\n}\n","import { _Vue } from './install'\nimport options from './options'\nimport utils from './utils'\nimport debug from './debug'\n\nexport default class VueRouterStore {\n  constructor (opt) {\n    this.options = options(opt = opt || {})\n    this._init()\n  }\n  _init () {\n    const store = {}\n    const _fetchKey = {}\n    Object.keys(this.options.modules).forEach(name => {\n      store[name] = {\n        list: this._getData(name, 'list'),\n        detail: this._getData(name, 'detail')\n      }\n      _fetchKey[name] = {\n        list: '',\n        detail: ''\n      }\n    })\n    this.store = new _Vue({\n      data: {\n        store\n      }\n    }).$data.store\n    this._fetchKey = _fetchKey\n  }\n  _getModuleOptions (name, type) {\n    const options = this.options.modules[name]\n    const defaults = {\n      pagekey: this.options.pagekey,\n      queryKey: this.options.queryKey,\n      paramsKey: this.options.detailParamsKey,\n      fetch (next) {\n        return {}\n      },\n      data () {\n        return {}\n      }\n    }\n    Object.keys(options).forEach(k => {\n      let name = (k.split(type)[1] || '')\n      name = name.replace(/^(\\w)/, (v) => v.toLowerCase()) // 首字母大写\n      if (name) {\n        defaults[name] = options[k]\n      } else {\n        defaults[name] = options[k]\n      }\n    })\n    return defaults\n  }\n  _returnComput (comput, diy) {\n    const obj = {}\n    if (!diy.length) return comput\n    diy.forEach(k => {\n      obj[k] = comput[k]\n    })\n    return obj\n  }\n  _getData (name, type) {\n    const data = this.options.baseData.call(this, name, type)\n    switch (type) {\n      case 'list':\n        Object.assign(data, this.options.baseListData.call(this, name))\n        break\n      case 'detail':\n        Object.assign(data, this.options.baseDetailData.call(this, name))\n        break\n    }\n    const options = this._getModuleOptions(name, type)\n    return Object.assign(data, options.data.call(this))\n  }\n  _clearStore (name, type) {\n    const data = this._getData(name, type)\n    this._setStore(name, type, data)\n  }\n  _getStore (name, type) {\n    return this.store[name][type]\n  }\n  _setStore (name, type, data) {\n    const store = this.store[name][type]\n    Object.assign(store, data)\n  }\n  _getComputed (name, type) {\n    const store = this.store[name][type]\n    const computed = {}\n    Object.keys(store).forEach(k => {\n      computed[k] = {\n        get () {\n          return store[k]\n        },\n        set (val) {\n          store[k] = val\n        }\n      }\n    })\n    return computed\n  }\n  _setFetchKey (name, type, val) {\n    this._fetchKey[name][type] = String(val)\n  }\n  _getFetchKey (name, type) {\n    return this._fetchKey[name][type]\n  }\n  listStore (name, ...diy) {\n    const self = this\n    const type = 'list'\n    const options = self._getModuleOptions(name, type)\n    const computed = {\n      ...self._getComputed(name, type),\n      $rsList () {\n        const vm = this\n\n        function rsList () {\n          const fetch = self._getModuleOptions(name, type).fetch\n          if (!utils.isFunction(fetch)) {\n            return debug.error(`${type} fetch method is undefined`)\n          }\n          const fullPath = vm.$route.fullPath\n          self.options.fetchBefore.call(vm, name, type)\n          utils.next(fetch.bind(vm), (res) => {\n            const back = self.options.fetchSuccess.call(vm, res, name, type)\n            if (utils.isObject(back)) {\n              res = back\n            }\n            if (fullPath !== vm.$route.fullPath) return\n            self._setStore(name, type, res)\n            self._setFetchKey(name, type, fullPath)\n            self.options.fetchAfter.call(vm, name, type)\n          }, (e) => {\n            self.options.fetchError.call(vm, e, name, type)\n            self.options.fetchAfter.call(vm, name, type)\n          })\n        }\n        rsList.init = function init () {\n          self._clearStore(name, type)\n        }\n\n        rsList.search = function search (...arg) {\n          let query = {}\n          /* eslint-disable no-undef */\n          if (typeof event === 'object' && event === arg[0]) {\n            arg[0] = {}\n          }\n          if (utils.isObject(arg[0])) { // search({})\n            query = arg[0]\n          } else if (typeof arg[0] === 'string') { // search('key', val)\n            query[arg[0]] = arg[1]\n          }\n          let myQuery = {}\n          if (vm.$route[options.pagekey]) {\n            myQuery[options.pagekey] = '1'\n          }\n          query = Object.assign({}, vm.$route.query, myQuery, vm[options.queryKey], query)\n          vm.$router.push({\n            ...vm.$route,\n            query\n          })\n        }\n        rsList.syncQuery = function syncQuery () {\n          const query = vm[options.queryKey]\n          if (utils.isObject(query)) {\n            Object.keys(query).forEach((k) => {\n              if (Object.prototype.hasOwnProperty.call(vm.$route.query, k)) {\n                query[k] = vm.$route.query[k]\n              }\n            })\n          }\n        }\n        return rsList\n      }\n    }\n    return this._returnComput(computed, diy)\n  }\n  listMixin (name) {\n    const self = this\n    const type = 'list'\n    return {\n      beforeRouteEnter (to, from, next) {\n        const key = self._getFetchKey(name, type)\n        const toKey = to.fullPath\n        if (!key) { // The first visit of the page\n          self._setFetchKey(name, type, toKey)\n        } else if (key !== toKey) {\n          // If the current access page is different from the previously accessed page\n          self._clearStore(name, type)\n          self._setFetchKey(name, type, toKey)\n        }\n        if (utils.isFunction(next)) {\n          next()\n        }\n      },\n      computed: self.listStore(name),\n      created () {\n        this.$rsList.syncQuery()\n        this.$rsList()\n      },\n      watch: {\n        '$route.fullPath' () {\n          this.$rsList.syncQuery()\n          this.$rsList()\n        }\n      }\n    }\n  }\n  detailStore (name, ...diy) {\n    const self = this\n    const type = 'detail'\n    const options = self._getModuleOptions(name, type)\n    const computed = {\n      ...self._getComputed(name, type),\n      $rsDetail () {\n        const vm = this\n        function rsDetail () {\n          const key = vm.$route.path\n          if (!vm.$route.params[options.paramsKey]) return\n          const fetch = options.fetch\n          if (!utils.isFunction(fetch)) {\n            return debug.error(`${type} fetch method is undefined`)\n          }\n          self.options.fetchBefore.call(vm, name, type)\n          utils.next(fetch.bind(vm), (res) => {\n            const back = self.options.fetchSuccess.call(vm, res, name, type)\n            if (utils.isObject(back)) {\n              res = back\n            }\n            if (key !== vm.$route.path) return\n            self._setStore(name, type, res)\n            self._setFetchKey(name, type, key)\n            self.options.fetchAfter.call(vm, name, type)\n          }, (e) => {\n            self.options.fetchError.call(vm, e, name, type)\n            self.options.fetchAfter.call(vm, name, type)\n          })\n        }\n        rsDetail.init = function init () {\n          self._clearStore(name, type)\n        }\n        return rsDetail\n      }\n    }\n    return this._returnComput(computed, diy)\n  }\n  detailMixin (name) {\n    const self = this\n    const type = 'detail'\n    return {\n      beforeRouteEnter (to, from, next) {\n        const key = self._getFetchKey(name, type)\n        if (!key) {\n          self._setFetchKey(name, type, to.path)\n        } else if (key && key !== to.path) {\n          self._clearStore(name, type)\n          self._setFetchKey(name, type, to.path)\n        }\n        if (utils.isFunction(next)) {\n          next()\n        }\n      },\n      computed: self.detailStore(name),\n      created () {\n        this.$rsDetail()\n      },\n      watch: {\n        '$route.path' () {\n          this.$rsDetail()\n        }\n      }\n    }\n  }\n}\n","import VueRouterStore from './vue-router-store'\nimport install from './install'\n\nVueRouterStore.install = install\n\nexport default VueRouterStore\n"],"names":["install","Vue","installed","defineProperty","prototype","this","$root","_vrs","store","mixin","isDef","$options","vrs","options","opt","name","type","res","e","Object","assign","_Vue","undefined","v","utils","obj","toString","call","arr","fn","resolve","reject","btn","back","isFunction","then","catch","msg","Error","VueRouterStore","_init","_fetchKey","keys","modules","forEach","_this","_getData","$data","defaults","pagekey","queryKey","detailParamsKey","next","k","split","replace","toLowerCase","comput","diy","length","data","baseData","baseListData","baseDetailData","_getModuleOptions","_setStore","computed","val","String","self","_getComputed","rsList","fetch","debug","error","fullPath","vm","$route","fetchBefore","bind","fetchSuccess","isObject","_setFetchKey","fetchAfter","fetchError","init","_clearStore","search","query","arg","event","myQuery","$router","push","syncQuery","hasOwnProperty","_returnComput","to","from","key","_getFetchKey","toKey","listStore","$rsList","rsDetail","path","params","paramsKey","detailStore","$rsDetail"],"mappings":"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"}