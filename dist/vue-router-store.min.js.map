{"version":3,"file":"vue-router-store.min.js","sources":["../src/install.js","../src/options.js","../src/utils.js","../src/debug.js","../src/vue-router-store.js","../src/index.js"],"sourcesContent":["export let _Vue = null\n\nconst isDef = v => v !== undefined\n\nexport default function install (Vue) {\n  if (install.installed) return\n  install.installed = true\n  _Vue = Vue\n  Object.defineProperty(Vue.prototype, '$vrs', {\n    get () { return this.$root._vrs }\n  })\n  Object.defineProperty(Vue.prototype, '$rs', {\n    get () { return this.$root._vrs.store }\n  })\n  Vue.mixin({\n    beforeCreate () {\n      if (isDef(this.$options.vrs)) {\n        this._vrs = this.$options.vrs\n      }\n    }\n  })\n}\n","export default function options (opt = {}) {\n  const options = {\n    pagekey: 'page', // this.$route.query[pagekey]\n    queryKey: 'query', // this.$data[queryKey]\n    fetchBefore (name, type) {\n      // Callback method before requesting to send\n      // This points to the component instance\n    },\n    fetchAfter (name, type) {\n      // After the request ends, the callback method, regardless of success or failure\n      // This points to the component instance\n    },\n    fetchSuccess (res, name, type) {\n      // Request successful callback\n    },\n    fetchError (e, name, type) {\n      // Request failed callback\n    },\n    baseData (name, type) {\n      // All use\n      return {}\n    },\n    baseListData (name) {\n      // List all use\n      return {}\n    },\n    baseDetailData (name) {\n      // Detail all use\n      return {}\n    },\n    modules: {}\n  }\n  return Object.assign(options, opt)\n}\n","const utils = {\n  isObject (obj) {\n    return Object.prototype.toString.call(obj) === '[object Object]'\n  },\n  isArray (arr) {\n    return Object.prototype.toString.call(arr) === '[object Array]'\n  },\n  isFunction (arr) {\n    return Object.prototype.toString.call(arr) === '[object Function]'\n  },\n  next (fn, resolve, reject = (e) => {}) {\n    let btn = false\n    const back = fn(resolve, reject)\n    if (typeof back === 'object' && utils.isFunction(back.then)) {\n      back\n        .then((res) => {\n          if (btn) return\n          btn = true\n          resolve(res)\n        })\n        .catch(reject)\n    }\n  }\n}\nexport default utils\n","export default {\n  error (msg) {\n    throw new Error(`[vue-router-store] ${msg}`)\n  },\n  warn (msg) {\n    if (process.env.NODE_ENV !== 'production') {\n      typeof console !== 'undefined' && console.warn(`[vue-router-store] ${msg}`)\n    }\n  }\n}\n","import { _Vue } from './install'\nimport options from './options'\nimport utils from './utils'\nimport debug from './debug'\n\nexport default class VueRouterStore {\n  constructor (opt) {\n    this.options = options(opt = opt || {})\n    this._init()\n  }\n  _init () {\n    const store = {}\n    const _fetchKey = {}\n    Object.keys(this.options.modules).forEach(name => {\n      store[name] = {\n        list: this._getData(name, 'list'),\n        detail: this._getData(name, 'detail')\n      }\n      _fetchKey[name] = {\n        list: '',\n        detail: ''\n      }\n    })\n    this.store = new _Vue({\n      data: {\n        store\n      }\n    }).$data.store\n    this._fetchKey = _fetchKey\n  }\n  _getModuleOptions (name, type) {\n    const options = this.options.modules[name]\n    const defaults = {\n      pagekey: this.options.pagekey,\n      queryKey: this.options.queryKey,\n      fetch (next) {\n        return {}\n      },\n      data () {\n        return {}\n      }\n    }\n    Object.keys(options).forEach(k => {\n      let name = (k.split(type)[1] || '')\n      name = name.replace(/^(\\w)/, (v) => v.toLowerCase()) // 首字母大写\n      if (name) {\n        defaults[name] = options[k]\n      } else {\n        defaults[name] = options[k]\n      }\n    })\n    return defaults\n  }\n  _returnComput (comput, diy) {\n    const obj = {}\n    if (!diy.length) return comput\n    diy.forEach(k => {\n      obj[k] = comput[k]\n    })\n    return obj\n  }\n  _getData (name, type) {\n    const data = this.options.baseData.call(this, name, type)\n    switch (type) {\n      case 'list':\n        Object.assign(data, this.options.baseListData.call(this, name))\n        break\n      case 'detail':\n        Object.assign(data, this.options.baseDetailData.call(this, name))\n        break\n    }\n    const options = this._getModuleOptions(name, type)\n    return Object.assign(data, options.data.call(this))\n  }\n  _clearStore (name, type) {\n    const data = this._getData(name, type)\n    this._setStore(name, type, data)\n  }\n  _getStore (name, type) {\n    return this.store[name][type]\n  }\n  _setStore (name, type, data) {\n    const store = this.store[name][type]\n    Object.assign(store, data)\n  }\n  _getComputed (name, type) {\n    const store = this.store[name][type]\n    const computed = {}\n    Object.keys(store).forEach(k => {\n      computed[k] = {\n        get () {\n          return store[k]\n        },\n        set (val) {\n          store[k] = val\n        }\n      }\n    })\n    return computed\n  }\n  _setFetchKey (name, type, val) {\n    this._fetchKey[name][type] = String(val)\n  }\n  _getFetchKey (name, type) {\n    return this._fetchKey[name][type]\n  }\n  listStore (name, ...diy) {\n    const self = this\n    const type = 'list'\n    const options = self._getModuleOptions(name, type)\n    const computed = {\n      ...self._getComputed(name, type),\n      $rsList () {\n        const vm = this\n\n        function rsList () {\n          const fetch = self._getModuleOptions(name, type).fetch\n          if (!utils.isFunction(fetch)) {\n            return debug.error(`${type} fetch method is undefined`)\n          }\n          const fullPath = vm.$route.fullPath\n          self.options.fetchBefore.call(vm, name, type)\n          utils.next(fetch.bind(vm), (res) => {\n            const back = self.options.fetchSuccess.call(vm, res, name, type)\n            if (utils.isObject(back)) {\n              res = back\n            }\n            if (fullPath !== vm.$route.fullPath) return\n            self._setStore(name, type, res)\n            self._setFetchKey(name, type, fullPath)\n            self.options.fetchAfter.call(vm, name, type)\n          }, (e) => {\n            self.options.fetchError.call(vm, e, name, type)\n            self.options.fetchAfter.call(vm, name, type)\n          })\n        }\n        rsList.init = function init () {\n          self._clearStore(name, type)\n        }\n\n        rsList.search = function search (...arg) {\n          let query = {}\n          /* eslint-disable no-undef */\n          if (typeof event === 'object' && event === arg[0]) {\n            arg[0] = {}\n          }\n          if (utils.isObject(arg[0])) { // search({})\n            query = arg[0]\n          } else if (typeof arg[0] === 'string') { // search('key', val)\n            query[arg[0]] = arg[1]\n          }\n          query = Object.assign({}, vm.$route.query, { [options.pagekey]: '1' }, vm[options.queryKey], query)\n          vm.$router.push({\n            ...vm.$route,\n            query\n          })\n        }\n        rsList.syncQuery = function syncQuery () {\n          const query = vm[options.queryKey]\n          if (utils.isObject(query)) {\n            Object.keys(query).forEach((k) => {\n              if (Object.prototype.hasOwnProperty.call(vm.$route.query, k)) {\n                query[k] = vm.$route.query[k]\n              }\n            })\n          }\n        }\n        return rsList\n      }\n    }\n    return this._returnComput(computed, diy)\n  }\n  listMixin (name) {\n    const self = this\n    const type = 'list'\n    return {\n      beforeRouteEnter (to, from, next) {\n        const key = self._getFetchKey(name, type)\n        const toKey = to.fullPath\n        if (!key) {\n          self._setFetchKey(name, type, toKey)\n        } else if (key !== toKey) {\n          self._clearStore(name, type)\n          self._setFetchKey(name, type, toKey)\n        }\n        if (utils.isFunction(next)) {\n          next()\n        }\n      },\n      computed: self.listStore(name),\n      created () {\n        this.$rsList.syncQuery()\n        this.$rsList()\n      },\n      watch: {\n        '$route.fullPath' () {\n          this.$rsList.syncQuery()\n          this.$rsList()\n        }\n      }\n    }\n  }\n  detailStore (name, ...diy) {\n    const self = this\n    const type = 'detail'\n    const computed = {\n      ...self._getComputed(name, type),\n      $rsDetail () {\n        const vm = this\n        function rsDetail () {\n          const key = vm.$route.path\n          if (!key) return\n          const fetch = self._getModuleOptions(name, type).fetch\n          if (!utils.isFunction(fetch)) {\n            return debug.error(`${type} fetch method is undefined`)\n          }\n          self.options.fetchBefore.call(vm, name, type)\n          utils.next(fetch.bind(vm), (res) => {\n            const back = self.options.fetchSuccess.call(vm, res, name, type)\n            if (utils.isObject(back)) {\n              res = back\n            }\n            if (key !== vm.$route.path) return\n            self._setStore(name, type, res)\n            self._setFetchKey(name, type, key)\n            self.options.fetchAfter.call(vm, name, type)\n          }, (e) => {\n            self.options.fetchError.call(vm, e, name, type)\n            self.options.fetchAfter.call(vm, name, type)\n          })\n        }\n        rsDetail.init = function init () {\n          self._clearStore(name, type)\n        }\n        return rsDetail\n      }\n    }\n    return this._returnComput(computed, diy)\n  }\n  detailMixin (name) {\n    const self = this\n    const type = 'detail'\n    return {\n      beforeRouteEnter (to, from, next) {\n        const key = self._getFetchKey(name, type)\n        if (!key) {\n          self._setFetchKey(name, type, to.path)\n        } else if (key && key !== to.path) {\n          self._clearStore(name, type)\n          self._setFetchKey(name, type, to.path)\n        }\n        if (utils.isFunction(next)) {\n          next()\n        }\n      },\n      computed: self.detailStore(name),\n      created () {\n        this.$rsDetail()\n      },\n      watch: {\n        '$route.path' () {\n          this.$rsDetail()\n        }\n      }\n    }\n  }\n}\n","import VueRouterStore from './vue-router-store'\nimport install from './install'\n\nVueRouterStore.install = install\n\nexport default VueRouterStore\n"],"names":["install","Vue","installed","defineProperty","prototype","this","$root","_vrs","store","mixin","isDef","$options","vrs","options","opt","name","type","res","e","Object","assign","_Vue","undefined","v","utils","obj","toString","call","arr","fn","resolve","reject","btn","back","isFunction","then","catch","msg","Error","VueRouterStore","_init","_fetchKey","keys","modules","forEach","_this","_getData","$data","defaults","pagekey","queryKey","next","k","split","replace","toLowerCase","comput","diy","length","data","baseData","baseListData","baseDetailData","_getModuleOptions","_setStore","computed","val","String","self","_getComputed","rsList","fetch","debug","error","fullPath","vm","$route","fetchBefore","bind","fetchSuccess","isObject","_setFetchKey","fetchAfter","fetchError","init","_clearStore","search","query","arg","event","$router","push","syncQuery","hasOwnProperty","_returnComput","to","from","key","_getFetchKey","toKey","listStore","$rsList","rsDetail","path","detailStore","$rsDetail"],"mappings":"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"}